using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SlicerProto.ObjectModel;
using SlicerProto.SliceModel;
using SlicerProto.SliceFill;
using SlicerProto.Utils;
using SlicerProto.Options;
using System.Globalization;
using OpenTK;

namespace SlicerProto.Export
{
    public class GCodeExporter : IExporter
    {
        private int previousSpeed = -1;
        Vector3 prevPoint = Vector3.Zero;

        public GCodeExporter(Model model, SlicerOptions options, Vector2 offset)
        {
            Model = model ?? throw new ArgumentNullException("model");
            Options = options ?? throw new ArgumentNullException("options");
            ObjectDimensions dimensions = model.Dimensions;
            Position = new Vector3(offset.X - (dimensions.Size.X / 2 + dimensions.MinPoint.X),
                offset.Y - (dimensions.Size.Y / 2 + dimensions.MinPoint.Y), -dimensions.MinPoint.Z);
        }

        public Model Model { get; private set; }
        public SlicerOptions Options { get; private set; }
        public Vector3 Position { get; private set; }
        public ISliceExpander Expander { get; set; }

        public TimeSpan EstimatedTime { get; private set; } = TimeSpan.Zero;

        public event EventHandler<ExportProgressEventArgs> OnProgress;

        private bool RaiseOnProgress(int progress)
        {
            if (OnProgress == null)
                return false;
            ExportProgressEventArgs args = new ExportProgressEventArgs(progress);
            OnProgress(this, args);
            return args.Abort;
        }

        public void Export(string fileName)
        {
            using (FileStream fs = new FileStream(fileName, FileMode.Create, FileAccess.Write))
            {
                Export(fs);
            }
        }

        public void Export(Stream stream)
        {
            using (StreamWriter writer = new StreamWriter(stream, Encoding.ASCII, 4096, true))
            {
                previousSpeed = -1;
                prevPoint = Options.Printer.GetHomePosition();
                EstimatedTime = TimeSpan.Zero;
                WriteHeader(writer);
                WritePreamble(writer);
                WriteSkirt(writer);
                WriteModel(writer);
                WriteEpilogue(writer);
            }
        }

        private void WriteHeader(StreamWriter writer)
        {
            writer.WriteLine("; G-Code generated by Slicer, (C) 2019 Nadezhda Tabunnikova");
            writer.WriteLine($"; {DateTime.Now.ToString("G")}");
            writer.WriteLine("; Settings");
            writer.WriteLine($";  Model: {Model.Name}");
            writer.WriteLine($";  Extruder diameter: {Options.Printer.ExtruderDiameter}");
            writer.WriteLine($";  Extruder temperature: {Options.Printer.ExtruderTemperature}");
            writer.WriteLine($";  Heated bed: {Options.Printer.TableHeating}");
            if (Options.Printer.TableHeating)
                writer.WriteLine($";  Bed temperature: {Options.Printer.TableTemperature}");
            writer.WriteLine($";  Layer height: {Options.Slice.Step}");
            writer.WriteLine($";  Cooling fan: {Options.Printer.UseFan}");
            if (Options.Printer.UseFan)
                writer.WriteLine($";  Fan speed: {Options.Printer.FanSpeed}");
            writer.WriteLine($";  Retract distance: {Options.Printer.RetractDistance}");
        }

        private void WritePreamble(StreamWriter writer)
        {
            writer.WriteLine("; Preamble");
            writer.WriteLine("G90"); // Абсолютное позиционирование
            writer.WriteLine("M82"); // Экструдер в абсолютный режим
            if (Options.Printer.UseFan)
                writer.WriteLine("M106 S0"); // Выключить вентилятор
            if (Options.Printer.TableHeating)
            {
                string bedTemperature = Options.Printer.TableTemperature.ToString(CultureInfo.InvariantCulture);
                writer.WriteLine($"M140 S{bedTemperature}"); // Включить нагрев стола 
                writer.WriteLine($"M190 S{bedTemperature}"); // Ожидать окончания нагрева стола 
            }
            string extruderTemperature = Options.Printer.ExtruderTemperature.ToString(CultureInfo.InvariantCulture);
            writer.WriteLine($"M104 S{extruderTemperature} T0"); // Включить нагрев экструдера 
            writer.WriteLine($"M109 S{extruderTemperature} T0"); // Ожидать окончания нагрева экструдера 
            writer.WriteLine("G28"); // Домой по всем осям
            writer.WriteLine("G92 E0"); // Домой по оси экструзии
            WriteE(writer, -Options.Printer.RetractDistance, Options.Printer.SpeedE); // Ретракт
            WriteZ(writer, Options.Slice.Offset, Options.Printer.SpeedZ); // Поднять стол
        }

        private void WriteEpilogue(StreamWriter writer)
        {
            writer.WriteLine("; Epilogue");
            writer.WriteLine("M104 S0"); // Выключить нагрев экструдера 
            if (Options.Printer.TableHeating)
                writer.WriteLine($"M140 S0"); // Выключить нагрев стола 
            writer.WriteLine("G28 Z"); // Домой по оси Z 
            writer.WriteLine("M107"); // Выключить охлаждение 
            writer.WriteLine("M84"); // Выключить моторы 
        }

        private void WriteModel(StreamWriter writer)
        {
            writer.WriteLine("; Model");

            float delta = Options.Slice.Step;
            int count = (int)Math.Truncate(Model.Dimensions.Size.Z / delta) + 1;
            int startSolidLayerIndex = Options.Fill.SolidLayerCount;
            int endSolidLayerIndex = count - Options.Fill.SolidLayerCount - 1;
            for (int i = 0; i < count; i++)
            {
                if (RaiseOnProgress(i * 100 / count))
                    return;

                if (i == 1 && Options.Printer.UseFan)
                    writer.WriteLine($"M106 S{Options.Printer.FanSpeed * 255 / 100}"); // Включить вентилятор

                float z = Model.Dimensions.MinPoint.Z + delta * (i + 1);
                Slice outerPerimeter = Model.GetSlice(z, Options);
                outerPerimeter.Index = i;

                if (outerPerimeter.Parts.Count > 0)
                {
                    writer.WriteLine($"; Layer {i}, Z={z.ToString(CultureInfo.InvariantCulture)}");
                    WritePerimeter(writer, outerPerimeter, delta * i);

                    Slice fillPerimeter = outerPerimeter;
                    if (Expander != null)
                    {
                        Slice innerPerimeter = outerPerimeter.Expand(Expander, -Options.Printer.ExtruderDiameter);
                        WritePerimeter(writer, innerPerimeter, 0f);

                        if (Options.Fill.FillLocation == FillLocation.InnerPerimeter)
                        {
                            fillPerimeter = innerPerimeter;
                        }
                        else if (Options.Fill.FillLocation == FillLocation.InsideInnerPerimeter)
                        {
                            fillPerimeter = outerPerimeter.Expand(Expander, -Options.Printer.ExtruderDiameter * 2);
                        }
                    }

                    FillFactory fillFactory = CreateFillFactory();
                    fillFactory.LayerByLayer = Options.Fill.LayerByLayer;
                    float fillStep = (i < startSolidLayerIndex || i >= endSolidLayerIndex) ?
                        Options.Printer.ExtruderDiameter : // Solid layer
                        Options.Printer.ExtruderDiameter * 100f / Options.Fill.Percentage; // Regular fill
                    Fill fill = fillFactory.CreateFill(fillPerimeter, (float)(Options.Fill.AngleInDegrees * Math.PI / 180), fillStep);
                    WriteFill(writer, fill);
                }
            }
        }

        private void WritePerimeter(StreamWriter writer, Slice slice, float sliceZ)
        {
            foreach (SlicePart part in slice.Parts)
            {
                Vector3 currentPoint = part.Points[0] + Position;
                Vector3 movement = currentPoint - prevPoint;
                float distance = movement.Length;
                WriteXY(writer, currentPoint.X, currentPoint.Y, Options.Printer.SpeedXYFast);
                CalcEstimatedTime(distance, Options.Printer.SpeedXYFast);
                prevPoint = currentPoint;
                if (sliceZ > 0f)
                    WriteZ(writer, sliceZ + Options.Slice.Offset, Options.Printer.SpeedZ);
                WriteE(writer, 0f, Options.Printer.SpeedE);
                writer.WriteLine("G92 E0");
                float filament = 0f;
                for (int i = 1; i < part.Points.Count; i++)
                {
                    currentPoint = part.Points[i] + Position;
                    movement = currentPoint - prevPoint;
                    distance = movement.Length;
                    filament += distance * Options.Printer.FilamentRate;
                    WriteXYE(writer, currentPoint.X, currentPoint.Y, filament, Options.Printer.SpeedXYSlow);
                    CalcEstimatedTime(distance, Options.Printer.SpeedXYSlow);
                    prevPoint = currentPoint;
                }
                if (part.Closed)
                {
                    currentPoint = part.Points[0] + Position;
                    movement = currentPoint - prevPoint;
                    distance = movement.Length;
                    filament += distance * Options.Printer.FilamentRate;
                    WriteXYE(writer, currentPoint.X, currentPoint.Y, filament, Options.Printer.SpeedXYSlow);
                    CalcEstimatedTime(distance, Options.Printer.SpeedXYSlow);
                    prevPoint = currentPoint;
                }
                writer.WriteLine("G92 E0");
                WriteE(writer, -Options.Printer.RetractDistance, Options.Printer.SpeedE); // Ретракт
            }

        }

        private FillFactory CreateFillFactory()
        {
            switch (Options.Fill.FillType)
            {
                case FillType.CrossHatch:
                    return new CrossHatchFillFactory()
                    {
                        CrossAngle = (float)(Options.Fill.CrossAngleInDegrees * Math.PI / 180)
                    };
                case FillType.Triangle:
                    return new TriangleFillFactory();
            }
            return new HatchFillFactory();
        }

        private void WriteFill(StreamWriter writer, Fill fill)
        {
            foreach (FillPart part in fill.Parts)
            {
                Vector3 currentPoint = part.Points[0] + Position;
                Vector3 movement = currentPoint - prevPoint;
                WriteXY(writer, currentPoint.X, currentPoint.Y, Options.Printer.SpeedXYFast);
                CalcEstimatedTime(movement.Length, Options.Printer.SpeedXYFast);
                prevPoint = currentPoint;
                WriteE(writer, 0f, Options.Printer.SpeedE);
                writer.WriteLine("G92 E0");
                float filament = 0f;
                for (int i = 1; i < part.Points.Count; i++)
                {
                    currentPoint = (part.Points[i] + Position);
                    movement = currentPoint - prevPoint;
                    float distance = movement.Length;
                    filament += distance * Options.Printer.FilamentRate;
                    WriteXYE(writer, currentPoint.X, currentPoint.Y, filament, Options.Printer.SpeedXYSlow);
                    CalcEstimatedTime(distance, Options.Printer.SpeedXYSlow);
                    prevPoint = currentPoint;
                }
                writer.WriteLine("G92 E0");
                WriteE(writer, -Options.Printer.RetractDistance, Options.Printer.SpeedE);
            }
        }

        private void WriteSkirt(StreamWriter writer)
        {
            if (!Options.Skirt.Enabled || Expander == null)
                return;

            writer.WriteLine("; Skirt");

            Slice perimeter = Model.GetSkirt(1f, Options);
            WritePerimeter(writer, perimeter, 0f);
            for (int i = 1; i < Options.Skirt.Count; i++)
            {
                perimeter = perimeter.Expand(Expander, -Options.Skirt.Step);
                WritePerimeter(writer, perimeter, 0f);
            }
        }

        private void WriteXY(StreamWriter writer, float x, float y, int speed)
        {
            string xs = x.ToString("0.000", CultureInfo.InvariantCulture);
            string ys = y.ToString("0.000", CultureInfo.InvariantCulture);
            if (speed == previousSpeed)
                writer.WriteLine($"G1 X{xs} Y{ys}");
            else
                writer.WriteLine($"G1 X{xs} Y{ys} F{speed.ToString()}");
            previousSpeed = speed;
        }

        private void WriteXYE(StreamWriter writer, float x, float y, float e, int speed)
        {
            string xs = x.ToString("0.000", CultureInfo.InvariantCulture);
            string ys = y.ToString("0.000", CultureInfo.InvariantCulture);
            string es = e.ToString("0.0000", CultureInfo.InvariantCulture);
            if (speed == previousSpeed)
                writer.WriteLine($"G1 X{xs} Y{ys} E{es}");
            else
                writer.WriteLine($"G1 X{xs} Y{ys} E{es} F{speed.ToString()}");
            previousSpeed = speed;
        }

        private void WriteE(StreamWriter writer, float e, int speed)
        {
            string es = e.ToString("0.0000", CultureInfo.InvariantCulture);
            if (speed == previousSpeed)
                writer.WriteLine($"G1 E{es}");
            else
                writer.WriteLine($"G1 E{es} F{speed.ToString()}");
            previousSpeed = speed;
        }

        private void WriteZ(StreamWriter writer, float z, int speed)
        {
            string zs = z.ToString("0.000", CultureInfo.InvariantCulture);
            if (speed == previousSpeed)
                writer.WriteLine($"G1 Z{zs}");
            else
                writer.WriteLine($"G1 Z{zs} F{speed.ToString()}");
            previousSpeed = speed;
        }

        private void CalcEstimatedTime(double distance, int speed)
        {
            TimeSpan ts = TimeSpan.FromMinutes(distance / speed);
            EstimatedTime = EstimatedTime.Add(ts);
        }
    }
}
